"""The successor to pySAP"""

import os
from subprocess import Popen, PIPE, STDOUT
from termcolor import colored
import subprocess
import sys
import json
import glob
import getpass
import re

STAMP = """; Code autogenerated by SAPplus
"""


with open("sapplus_config.json") as fl:
    config = json.load(fl)

def run(project, vm_path):
    p = subprocess.Popen([vm_path], stdin=subprocess.PIPE, shell=True)
    p.communicate(input=bytes(project+".bin\nquit", 'utf8'))


class SAPMacro:
    def __init__(self):
        self.preserve_indentation = True
        self.match = ".+"
        self.debug_comment = True
        self.header_insertion = None

    def on_readline(self, line):
        pass


class AssignMacro(SAPMacro):
    def __init__(self):
        super().__init__()
        self.match = "\w+ ?="

    def on_readline(self, line):
        insertion = []
        parts = line.split("=")
        var = parts[0].strip()
        value = parts[1].strip()

        assign_to_reg = False
        output_reg = 1

        if re.match("r\d+", var):
            assign_to_reg = True
            output_reg = var.strip("r")
        else:
            insertion.append("push r"+str(output_reg))

        insertion+=arg_to_register(value, output_reg)

        if not assign_to_reg:
            insertion.append(f"movrm r{output_reg} {var}")
            insertion.append(f"pop r{output_reg}")
        return insertion


class PrintMacro(SAPMacro):
    def __init__(self):
        super().__init__()
        self.match = "print "
        self.str_count = 0

    def on_readline(self, line):
        self.header_insertion = []
        insertion = []

        parts = parse_dsv(line,[" "])[::2]
        args = parts[1:]

        for arg in args:
            if re.match('".+"', arg):
                tmp_label = "STRTMP"+str(self.str_count)
                self.str_count += 1

                self.header_insertion.append(f'{tmp_label}: .string {arg}')
                insertion.append("outs "+tmp_label)
            else:
                insertion.append("push r1")
                insertion+=arg_to_register(arg, 1)
                insertion.append("printi r1")
                insertion.append("pop r1")


            insertion.append("outci #32")
        insertion = insertion[:-1]
        return insertion


class PrintlnMacro(PrintMacro):
    def __init__(self):
        super().__init__()
        self.match = "println"
        self.str_count = 0

    def on_readline(self, line):
        insertion = super().on_readline(line)
        insertion.append("outci #10")
        return insertion


class CallMacro(SAPMacro):
    def __init__(self):
        super().__init__()
        self.match = "call"

    def on_readline(self, line):
        insertion = []

        instruction = line.strip()
        subroutine = instruction.split(" ")[1]
        args = instruction.split(" ")[2:]

        should_pop = []

        arg_num = 1
        for arg in args:
            if arg_num == 5:
                print("SAP supports a maximum of 4 arguments to subroutines")
                exit()
            insertion.append(f"push r{arg_num}")
            if re.fullmatch("r\d+", arg):  # Pass register as argument
                insertion.append(f"movrr {arg} r{arg_num}")

            elif arg.startswith('#'):  # Pass integer constant as argument
                insertion.append(f"movir {arg} r{arg_num}")
            elif arg.startswith("*"):  # Pass dereferenced value as argument
                arg = arg[1:]
                if re.match("r\d+", arg):  # Pass value of pointer register
                    insertion.append(f"movrr {arg} r{arg_num}")
                else:  # Pass value of label
                    insertion.append(f"movar {arg} r{arg_num}")
                insertion.append(f"movxr r{arg_num} r{arg_num}")
            elif arg.startswith("&"):  # Pass pointer to label as argument
                arg = arg[1:]
                insertion.append(f"movar {arg} r{arg_num}")
            else:
                print(
                    f"{arg} is not a valid argument. If you're passing a label, you need to pass as its address or dereference it")
                exit()
            should_pop.append(arg_num)
            arg_num += 1
        insertion.append(f"jsr {subroutine}")
        while should_pop:
            insertion.append(f"pop r{should_pop.pop()}")

        return insertion


def simple_macro_runner(insertion, argnames, args):
    insertion = insertion[:]
    for i, line in enumerate(insertion):
        for name, value in zip(argnames, args):
            insertion[i] = line.replace("$"+name, value)
            if "$"+name in line:
                break

    return insertion


class SimpleMacro(SAPMacro):
    def __init__(self, signature, insertion):
        super().__init__()
        self.insertion = insertion

        parts = signature.split(" ")
        self.name = parts[0]
        self.match = parts[0]
        self.argnames = parts[1:]

    def on_readline(self, line):
        line = line.strip()
        values = line.split(" ")[1:]
        return simple_macro_runner(self.insertion, self.argnames, values)


def simple_macro_type(signature, insertion):
    return lambda: SimpleMacro(signature, insertion)


def load_extension(json_data: str):
    macros = json.loads(json_data)
    macro_types = []

    for signature in macros:
        insertion = macros[signature]

        macro_types.append(simple_macro_type(signature, insertion))
    return macro_types


def apply_macro(T: type, _lines):
    macro = T()
    header = []
    lines = _lines[:]
    for i, line in enumerate(_lines):
        if not re.match(macro.match, line.strip()):
            continue

        insertion = macro.on_readline(line.strip())

        if macro.header_insertion:
            header += macro.header_insertion

        if macro.debug_comment:
            insertion[0] += " ; "+line.strip()

        if macro.preserve_indentation and line.lstrip() != line:
            for j, new_line in enumerate(insertion):
                insertion[j] = "    "+new_line.strip()

        lines[i] = "\n".join(insertion)

    return header+lines


def compress(_lines):
    lines = []
    for line in _lines:
        if line.strip().startswith(";") or line.strip() == "":
            continue

        comment = re.findall(" ?;.+$", line)
        if comment:
            line = rcut(line, comment[0])
        lines.append(line)
    return lines


def fix_empty_labels(_lines):
    lines = []
    skip = False
    for i, line in enumerate(_lines):
        if skip:
            skip = False
            continue
        if re.search(':(\s+)?$', line):
            lines.append(line.rstrip()+" "+_lines[i+1].strip())
            skip = True
        else:
            lines.append(line)
    return lines


def stamp(lines: list):
    lines.insert(0, STAMP)

def compare_args(a, b):
    insertion = []
    insertion.append("push r1")
    insertion.append("push r2")
    insertion+=arg_to_register(a, 1)
    insertion+=arg_to_register(b, 2)
    insertion.append("cmprr r1 r2")
    insertion.append("pop r2")
    insertion.append("pop r1")
    return insertion

class Branch:
    def __init__(self):
        self.condition = None
        self.blocks = []
    def add_block(self, b):
        self.blocks.append(b)

def parse_if_chunks(_lines):
    chunks = []
    branch = Branch()
    bnblock = []
    nest = 0
    for line in _lines:
        if nest == 1:
            if line.strip().startswith("else"):
                branch.add_block(bnblock)
                bnblock = []
                # [None]
                # if line.strip().startswith("else if "):
                #     bnblock[0] = line
                
            elif line.strip().startswith("endif"):
                branch.add_block(bnblock)
                bnblock = []
            else:
                bnblock.append(line)
        if nest > 1:
            bnblock.append(line)

        if line.strip().startswith("if "):
            nest+=1
            if nest == 1:
                branch.condition = line
        if line.strip().startswith("endif"):
            nest-=1
            
            if nest == 0:
                chunks.append(branch)
                branch = Branch()
        elif nest == 0:
            chunks.append(line)
    return chunks

def convert_ifs(_lines, prefix=""):
    chunks = parse_if_chunks(_lines)
    lines = []
    branch_id = 0
    for chunk in chunks:
        if isinstance(chunk, Branch):
            condition = lcut(chunk.condition.strip(),"if").replace(" ", "")
            ops = ("==", ">", "<", "!=")
            
            parts = None
            for op in ops:
                if op in condition:
                    a,b = condition.split(op)
                    break
            
            iflabel = "bnIF"+prefix+str(branch_id)
            elselabel = "bnELSE"+prefix+str(branch_id)
            endiflabel = "bnEND"+prefix+str(branch_id)

            insertion = compare_args(a,b)
            if op == "==":
                insertion.append("jmpz "+iflabel)
                insertion.append("jmp "+elselabel)
            elif op == "!=":
                insertion.append("jmpne "+iflabel)
                insertion.append("jmp "+elselabel)
            elif op == ">":
                insertion.append("jmpn "+iflabel)
                insertion.append("jmp "+elselabel)
            elif op == "<":
                insertion.append("jmpp "+iflabel)
                insertion.append("jmp "+elselabel)
            elif op == ">=":
                insertion.append("jmpp "+elselabel)
                insertion.append("jmp "+iflabel)
            elif op == "<=":
                insertion.append("jmpn "+elselabel)
                insertion.append("jmp "+iflabel)
            else:
                print("Invalid operation",op)
                exit()
            
            insertion.append(iflabel+":")
            insertion+=convert_ifs(chunk.blocks[0], prefix+"Nest")
            insertion.append("jmp "+endiflabel)
            if len(chunk.blocks) > 1:
                insertion.append(elselabel+":")
                insertion+=convert_ifs(chunk.blocks[1], prefix+"Nest")
            else:
                insertion.append(elselabel+": nop")
            insertion.append(endiflabel+": nop")
            lines+=insertion
            branch_id+=1
        else:
            lines.append(chunk)
    return lines


def preprocess(src):
    lines = src.split("\n")
    lines = compress(lines)
    lines = apply_macro(AssignMacro, lines)
    lines = apply_macro(CallMacro, lines)
    lines = apply_macro(PrintMacro, lines)
    lines = apply_macro(PrintlnMacro, lines)
    with open(config["instruction-set-extensions"]) as fl:
        ext_data = fl.read()
    for macro in load_extension(ext_data):
        lines = apply_macro(macro, lines)
    lines = convert_ifs(lines)
    lines = fix_empty_labels(lines)
    
    stamp(lines)

    return "\n".join(("\n".join(lines)).split("\n"))


def run_demo(argv):
    if "-h" in argv or "--help" in argv:
        print("""Use "python pySAP.py run" to also run the assembly program. Open config.json for options and more parameters. """)
        raise SystemExit

    asm_src = argv[0]
    src_project = os.path.splitext(asm_src)[0]

    vm_path = glob.glob("/Users/"+getpass.getuser()+"/Library/Developer/Xcode/DerivedData/" +
                        config["xcode-proj-name"]+"*")[0]+"/Build/Products/Debug/"+config["xcode-proj-name"]

    print(colored("\nPreprocessing...", "blue"))
    with open(asm_src) as fl:
        output = preprocess(fl.read())

    out_project = src_project+".expanded"
    with open(out_project+".txt", 'w') as fl:
        fl.write(output)

    print(colored("Assembling...", "blue"))
    proc = assemble(out_project)
    if proc.returncode != 0:
        print(colored("Assembler returned non-zero error code " +
                      str(p.returncode), "red"))
        exit()

    if not os.path.exists(out_project+".bin"):
        print()
        with open(out_project+".lst") as fl:
            offending, msgs = get_errors(fl.read())
            for line, msg in zip(offending, msgs):
                print(colored(line.strip(), "magenta"))
                print(colored("\tError: "+msg.strip("."), "red"))
        exit()

    if 'run' in argv:
        print(colored("Running...", "blue"))
        run(out_project, vm_path)


if __name__ == "__main__":
    run_demo(sys.argv[1:])
