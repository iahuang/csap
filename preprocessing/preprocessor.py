"""The successor to pySAP"""

import os
from subprocess import Popen, PIPE, STDOUT
from termcolor import colored
import subprocess
import sys
import json
import glob
import getpass
import re

from .macros import apply_macro, AssignMacro, CallMacro, PrintMacro, PrintlnMacro
from .simplemacro import simple_macro_type
from .util import rcut, lcut

from .ifsyntax import convert_ifs

STAMP = """; Code autogenerated by SAPplus
"""

def load_extension(macros):
    macro_types = []

    for signature in macros:
        insertion = macros[signature]

        macro_types.append(simple_macro_type(signature, insertion))
    return macro_types


def compress(_lines):
    lines = []
    for line in _lines:
        if line.strip().startswith(";") or line.strip() == "":
            continue

        comment = re.findall(" ?;.+$", line)
        if comment:
            line = rcut(line, comment[0])
        lines.append(line)
    return lines


def fix_empty_labels(_lines):
    lines = []
    skip = False
    for i, line in enumerate(_lines):
        if skip:
            skip = False
            continue
        if re.search(':(\s+)?$', line):
            lines.append(line.rstrip()+" "+_lines[i+1].strip())
            skip = True
        else:
            lines.append(line)
    return lines


def stamp(lines: list):
    lines.insert(0, STAMP)


class Preprocessor:
    def __init__(self):
        self.ext = {}

    def load_extension(self, json_data):
        extension = json.loads(json_data)
        for header in extension:
            self.ext[header] = extension[header]

    def preprocess(self, src):
        lines = src.split("\n")
        lines = compress(lines)
        lines = apply_macro(AssignMacro, lines)
        lines = apply_macro(CallMacro, lines)
        lines = apply_macro(PrintMacro, lines)
        lines = apply_macro(PrintlnMacro, lines)

        for macro in load_extension(self.ext):
            lines = apply_macro(macro, lines)
        lines = convert_ifs(lines)
        lines = fix_empty_labels(lines)

        stamp(lines)

        return "\n".join(("\n".join(lines)).split("\n"))
