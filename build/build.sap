; Code autogenerated by SAPplus

STRTMP0: .string "Jumped to null label, halting"
.start avrinit

registers: .allocate #32

overflow: .integer #0
negative: .integer #0
zero: .integer #0
carry: .integer #0

stackptr: .integer #0

labelnull: outs STRTMP0 ; println "Jumped to null label, halting"
    outci #10
    halt

tobinary: nop
    ; r1 is the value
    ; r2 is the pointer to the bytedump
    ; r5 is a copy of r1
    ; r6 is the remainder
    ; r7 is the number of bits pushed
    ; r8 is r1/2
    clrr r7
    addir #32 r2
biniter: movrr r1 r5
    divir #2 r1
    movrr r1 r8
    mulir #2 r1
    cmprr r1 r5
    movrr r8 r1
    clrr r6
    jmpne remainder1 ; if remainder is 1
    jmpz remainder0 ; if remainder is 0
remainder1: movir #1 r6
remainder0: cmpir #0 r5
    jmpz endbin
    push r6
    addir #1 r7

    jmp biniter

endbin: subrr r7 r2
ebiniter: pop r6
    movrx r6 r2
    addir #1 r2
    subir #1 r7
    cmpir #0 r7
    jmpne ebiniter
    
    ret

power: nop
    ; r0 a^b
    ; r1 a
    ; r2 b
    movir #1 r0
    cmpir #0 r2
    jmpz endpower
poweriter: mulrr r1 r0
    subir #1 r2
    cmpir #0 r2
    jmpne poweriter
endpower: ret

todecimal: nop
    ; r0 total
    ; r1 pointer to the bytedump
    ; r5 the exponent
    ; r6 digit term (n*2^x)

    addir #31 r1
    clrr r0
    clrr r5

todeciter: movxr r1 r6
    push r1
    push r2
    push r0
    movir #2 r1
    movrr r5 r2
    jsr power
    mulrr r0 r6

    pop r0
    pop r2
    pop r1

    addrr r6 r0    
    
    addir #1 r5
    subir #1 r1

    cmpir #32 r5
    jmpne todeciter

    ret

bitwiseand: nop
    ; r1 address of binary register
    ; r2 address of binary register
    ; r3 address of output binary register
    ; r5 offset
    ; r6 value1
    ; r7 value2
    ; r8 set value

    movir #0 r5
anditer: movxr r1 r6
    movxr r2 r7
    cmpir #1 r6
    jmpne andset0
    cmprr r6 r7
    jmpz andset1
    jmpne andset0
andset1: movir #1 r8
    jmp andnoset
andset0: movir #0 r8
andnoset: movrx r8 r3

    addir #1 r1
    addir #1 r2
    addir #1 r3
    addir #1 r5

    cmpir #32 r5
    jmpne anditer

    ret

avrpush: nop
    ; r1 value
    push r1 ; addim #1 stackptr
    movmr stackptr r1
    addir #1 r1
    movrm r1 stackptr
    pop r1
    movmr stackptr r4
    movrx r1 r4
    ret

avrpop: movmr stackptr r4
    movxr r4 r0
    push r1 ; subim #1 stackptr
    movmr stackptr r1
    subir #1 r1
    movrm r1 stackptr
    pop r1
    ret

avrret: nop
    ; Uses code manipulation to jump to a custom location
    jsr avrpop ; call avrpop
    movar retval r4
    addir #1 r4
    movrx r0 r4
retval: jmp labelnull

avrinit: movar programEnd r1
    movrm r1 stackptr
    push r2
    movar initCheckpoint r2
    addir #2 r2
    push r1 ; call avrpush r2
    movrr r2 r1
    jsr avrpush
    pop r1
    pop r2
    initCheckpoint: jmp main
    halt 
main: nop
    ; [GCC]  prologue: function 
    ; [GCC]  frame size = 0 
    ; [GCC]  stack size = 0 
    ; lds r24 a
    movar registers r1
    addir #24 r1
    movar a r2
    movxr r2 r2
    movrx r2 r1
    ; lds r25 a+1
    movar registers r1
    addir #25 r1
    movar a r2
    addir #1 r2
    movxr r2 r2
    movrx r2 r1
    ; lds r18 b
    movar registers r1
    addir #18 r1
    movar b r2
    movxr r2 r2
    movrx r2 r1
    ; lds r19 b+1
    movar registers r1
    addir #19 r1
    movar b r2
    addir #1 r2
    movxr r2 r2
    movrx r2 r1
    ; add r24 r18
    movar registers r1
    addir #24 r1
    movar registers r2
    addir #18 r2
    movxr r2 r2
    movxr r1 r3
push r1
push r2
movrr r3 r1
movir #255 r2
cmprr r1 r2
pop r2
pop r1
jmpn bnIF0
jmp bnELSE0
bnIF0: movir #255 r3
    push r1 ; movim #1 carry
    movir #1 r1
    movrm r1 carry
    pop r1
jmp bnEND0
bnELSE0: push r1 ; movim #0 carry
    movir #0 r1
    movrm r1 carry
    pop r1
bnEND0: nop
    addrr r2 r3
    movrx r3 r1
    ; adc r25 r19
    movar registers r1
    addir #25 r1
    movar registers r2
    addir #19 r2
    movxr r2 r2
    movxr r1 r3
push r1
push r2
movrr r3 r1
movir #255 r2
cmprr r1 r2
pop r2
pop r1
jmpn bnIF1
jmp bnELSE1
bnIF1: movir #255 r3
    push r1 ; movim #1 carry
    movir #1 r1
    movrm r1 carry
    pop r1
jmp bnEND1
bnELSE1: push r1 ; movim #0 carry
    movir #0 r1
    movrm r1 carry
    pop r1
bnEND1: nop
    addrr r2 r3
    addmr carry r3
    movrx r3 r1
    ; sts sum+1 r25
    movar sum r1
    addir #1 r1
    movar registers r2
    addir #25 r2
    movxr r2 r2
    movrx r2 r1
    ; sts sum r24
    movar sum r1
    movar registers r2
    addir #24 r2
    movxr r2 r2
    movrx r2 r1
    ; ldi r25 0
    movar registers r1
    addir #25 r1
    movir #0 r2
    movrx r2 r1
    ; ldi r24 0
    movar registers r1
    addir #24 r1
    movir #0 r2
    movrx r2 r1
    ; [GCC]  epilogue start 
    ; ret ret
    jsr avrret ; call avrret
sum: .allocate #2
b: .integer #2
    .integer #0
a: .integer #1
    .integer #0
programEnd: .integer #0
