; Code autogenerated by SAPplus

.start main

registers: .allocate #32

overflow: .integer #0
negative: .integer #0
zero: .integer #0
carry: .integer #0

tobinary: nop
    ; r1 is the value
    ; r2 is the pointer to the bytedump
    ; r5 is a copy of r1
    ; r6 is the remainder
    ; r7 is the number of bits pushed
    ; r8 is r1/2
    clrr r7
    addir #32 r2
biniter: movrr r1 r5
    divir #2 r1
    movrr r1 r8
    mulir #2 r1
    cmprr r1 r5
    movrr r8 r1
    clrr r6
    jmpne remainder1 ; if remainder is 1
    jmpz remainder0 ; if remainder is 0
remainder1: movir #1 r6
remainder0: cmpir #0 r5
    jmpz endbin
    push r6
    addir #1 r7

    jmp biniter

endbin: subrr r7 r2
ebiniter: pop r6
    movrx r6 r2
    addir #1 r2
    subir #1 r7
    cmpir #0 r7
    jmpne ebiniter
    
    ret

power: nop
    ; r0 a^b
    ; r1 a
    ; r2 b
    movir #1 r0
    cmpir #0 r2
    jmpz endpower
poweriter: mulrr r1 r0
    subir #1 r2
    cmpir #0 r2
    jmpne poweriter
endpower: ret

todecimal: nop
    ; r0 total
    ; r1 pointer to the bytedump
    ; r5 the exponent
    ; r6 digit term (n*2^x)

    addir #31 r1
    clrr r0
    clrr r5

todeciter: movxr r1 r6
    push r1
    push r2
    push r0
    movir #2 r1
    movrr r5 r2
    jsr power
    mulrr r0 r6

    pop r0
    pop r2
    pop r1

    addrr r6 r0    
    
    addir #1 r5
    subir #1 r1

    cmpir #32 r5
    jmpne todeciter

    ret

bitwiseand: nop
    ; r1 address of binary register
    ; r2 address of binary register
    ; r3 address of output binary register
    ; r5 offset
    ; r6 value1
    ; r7 value2
    ; r8 set value

    movir #0 r5
anditer: movxr r1 r6
    movxr r2 r7
    cmpir #1 r6
    jmpne andset0
    cmprr r6 r7
    jmpz andset1
    jmpne andset0
andset1: movir #1 r8
    jmp andnoset
andset0: movir #0 r8
andnoset: movrx r8 r3

    addir #1 r1
    addir #1 r2
    addir #1 r3
    addir #1 r5

    cmpir #32 r5
    jmpne anditer

    ret

main: nop
    ; [GCC]  prologue: function 
    ; [GCC]  frame size = 0 
    ; [GCC]  stack size = 0 
    ; lds r24 a
    movar registers r1
    addir #24 r1
    movar a r2
    movxr r2 r2
    movrx r2 r1
    ; lds r25 a+1
    movar registers r1
    addir #25 r1
    movar a r2
    addir #1 r2
    movxr r2 r2
    movrx r2 r1
    ; lds r18 b
    movar registers r1
    addir #18 r1
    movar b r2
    movxr r2 r2
    movrx r2 r1
    ; lds r19 b+1
    movar registers r1
    addir #19 r1
    movar b r2
    addir #1 r2
    movxr r2 r2
    movrx r2 r1
    ; add r24 r18
    movar registers r1
    addir #24 r1
    movar registers r2
    addir #18 r2
    movxr r2 r2
    movxr r1 r3
push r1
push r2
movrr r3 r1
movir #255 r2
cmprr r1 r2
pop r2
pop r1
jmpn bnIF0
jmp bnELSE0
bnIF0: movir #255 r3
    push r1 ; movim #1 carry
    movir #1 r1
    movrm r1 carry
    pop r1
jmp bnEND0
bnELSE0: push r1 ; movim #0 carry
    movir #0 r1
    movrm r1 carry
    pop r1
bnEND0: nop
push r1
push r2
movrr r3 r1
movir #127 r2
cmprr r1 r2
pop r2
pop r1
jmpn bnIF1
jmp bnELSE1
bnIF1: push r1 ; movim #1 negative
    movir #1 r1
    movrm r1 negative
    pop r1
jmp bnEND1
bnELSE1: push r1
push r2
movrr r3 r1
movir #0 r2
cmprr r1 r2
pop r2
pop r1
jmpp bnIFNest0
jmp bnELSENest0
bnIFNest0: mulir #-1 r3
    addir #128 r3
    push r1 ; movim #1 negative
    movir #1 r1
    movrm r1 negative
    pop r1
jmp bnENDNest0
bnELSENest0: push r1 ; movim #0 negative
    movir #0 r1
    movrm r1 negative
    pop r1
bnENDNest0: nop
bnEND1: nop
push r1
push r2
movrr r3 r1
movir #0 r2
cmprr r1 r2
pop r2
pop r1
jmpz bnIF2
jmp bnELSE2
bnIF2: push r1 ; movim #1 zero
    movir #1 r1
    movrm r1 zero
    pop r1
jmp bnEND2
bnELSE2: push r1 ; movim #0 zero
    movir #0 r1
    movrm r1 zero
    pop r1
bnEND2: nop
    addrr r2 r3
    movrx r3 r1
    ; [CSAP] Unsupported instruction adc
    ; [CSAP] Unsupported instruction sts
    ; [CSAP] Unsupported instruction sts
    ; [CSAP] Unsupported instruction ldi
    ; [CSAP] Unsupported instruction ldi
    ; [GCC]  epilogue start 
    ; [CSAP] Unsupported instruction ret
sum: .allocate #2
b: .integer #2
    .integer #0
a: .integer #1
    .integer #0
